#!/usr/bin/env python3
"""

abc - AI Bash Command

Source and documentation:

  https://github.com/alestic/abc

Credits:

  Written by Claude 3.5 Sonnet
  Prompt crafting by Eric Hammond

  Original Python command template generated by Claude 2 and GPT 4 Turbo
  prompted by Eric Hammond

"""

import argparse
import configparser
import shlex
import logging
import os
import signal
import sys
import subprocess
from typing import List, Dict, Optional, Tuple

import anthropic
from readchar import readchar
import distro

VERSION: str = "2024-07-14"
PROGRAM_NAME: str = "abc"

# Config file
DEFAULT_CONFIG_FILE: str = '~/.abc.conf'
DEFAULT_CONFIG_SECTION: str = 'default'

# Log format
LOG_FORMAT: str = f'%(asctime)s [{PROGRAM_NAME}] [%(levelname)s] %(message)s'
LOG_FORMAT_DATE: str = '%Y-%m-%d %H:%M:%S'

# LLM Constants
LLM_MODEL: str = "claude-3-5-sonnet-20240620"
LLM_TEMPERATURE: float = 0.0
LLM_MAX_TOKENS: int = 1000

def get_os_info():
    system = distro.name(pretty=True)
    version = distro.version(pretty=True)
    return f"{system} {version}".strip() or "POSIX"

SYSTEM_PROMPT: str = f"""You are an expert in bash commands for {get_os_info()}.
Given a description, generate the appropriate bash command(s) to accomplish the task.
Provide only the command(s) without any explanation.
Ensure the output can be directly copied and pasted into a terminal.
Use {get_os_info()}-specific commands when appropriate."""

def signal_handler(signum: int, frame: Optional[object]) -> None:
    print('\nprogram interrupted')
    sys.exit(1)

def setup_signal_handler() -> None:
    """Set up the signal handler for interrupts."""
    signal.signal(signal.SIGINT, signal_handler)

def create_argument_parser() -> argparse.ArgumentParser:
    """Create an argument parser for command-line arguments."""
    parser = argparse.ArgumentParser(description="abc - AI Bash Command")
    parser.add_argument('-s', '--config-section',
                        default=DEFAULT_CONFIG_SECTION,
                        help='Name of the configuration section to be used')
    parser.add_argument('-c', '--config', type=argparse.FileType('r'),
                        default=os.environ.get('ABC_CONFIG', os.path.expanduser(DEFAULT_CONFIG_FILE)),
                        help='Path to configuration file')
    parser.add_argument('--version', action='store_true',
                        help='Display the program version and exit')

    parser.add_argument('--mode', choices=['prompt', 'run', 'norun'],
                        default=None,
                        help='Mode of operation: prompt (default), run (without prompting), or norun (just show command)')

    parser.add_argument('--in-abc-bash-function', action='store_true',
                        help=f'Indicate that {PROGRAM_NAME} is being run inside the {PROGRAM_NAME} bash function')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--quiet', action='store_const',
                       const=logging.ERROR, dest='log_level',
                       help='Suppress all output except for errors and generated commands')
    group.add_argument('--verbose', action='store_const',
                       const=logging.INFO, dest='log_level',
                       help='Provide detailed information about the program execution')
    group.add_argument('--debug', action='store_const',
                       const=logging.DEBUG, dest='log_level',
                       help='Provide debug information, use this only when troubleshooting')
    parser.set_defaults(log_level=logging.WARNING)

    parser.add_argument('description', nargs=argparse.REMAINDER,
                        help='English description of the desired bash command')
    return parser

def read_config_file(config_file_path: str) -> configparser.ConfigParser:
    """Read and parse the configuration file."""
    config = configparser.ConfigParser()
    with open(config_file_path, 'r') as config_file:
        config.read_file(config_file)
    return config

def get_config_section(config: configparser.ConfigParser, section_name: str, config_file_path: str) -> Dict[str, str]:
    """Get the specified configuration section."""
    if not config.has_section(section_name):
        raise configparser.Error(f"Error: Section '{section_name}' not found in config file '{config_file_path}'")
    return dict(config[section_name])

def apply_default_options(parser: argparse.ArgumentParser, config_section: Dict[str, str], cmd_line_args: List[str]) -> argparse.Namespace:
    """Apply default options from the config section and then parse command-line arguments."""
    default_options = shlex.split(config_section.get('default_options', ''))
    default_args, _ = parser.parse_known_args(default_options)
    return parser.parse_args(args=cmd_line_args, namespace=default_args)

def generate_bash_command(description: str, api_key: str) -> str:
    """Generate a bash command using the LLM based on the given description."""
    client = anthropic.Anthropic(api_key=api_key)

    message = client.messages.create(
        model=LLM_MODEL,
        max_tokens=LLM_MAX_TOKENS,
        temperature=LLM_TEMPERATURE,
        system=SYSTEM_PROMPT,
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": f"Description: {description}\n\nBash command(s):"
                    }
                ]
            }
        ]
    )

    return message.content[0].text.strip()

def setup_logging(log_level: int) -> None:
    """Set up logging configuration."""
    logging.basicConfig(level=log_level, format=LOG_FORMAT, datefmt=LOG_FORMAT_DATE)

def validate_description(description: List[str]) -> None:
    """Validate the provided description."""
    if not description:
        raise ValueError("No description provided")

def process_command(description: List[str], config: Dict[str, str]) -> str:
    """Process the command description and generate bash command."""
    description_text = " ".join(description)
    logging.info(f"Generating bash command for: {description_text}")

    if 'api_key' not in config:
        raise ValueError("API key not found in configuration")

    return generate_bash_command(description_text, config['api_key'])

def run_bash_command(command: str) -> None:
    """Run the generated bash command."""
    try:
        subprocess.run(command, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"Command execution failed: {e}")
        sys.exit(1)

def prompt_and_run(command: str, mode: str) -> None:
    """Prompt the user to run the command and execute if confirmed."""
    print(command)

    if mode == 'norun':
        return

    if mode == 'run':
        run_bash_command(command)
        return

    # mode == 'prompt'
    sys.stdout.write("run (y/N)? ")
    sys.stdout.flush()
    user_input = readchar().lower()
    print(user_input)  # Print the user's input

    if user_input == 'y':
        run_bash_command(command)

def initialize() -> Tuple[argparse.Namespace, Dict[str, str]]:
    """Initialize the program by parsing arguments and reading the configuration."""
    setup_signal_handler()

    parser = create_argument_parser()
    cmd_line_args = sys.argv[1:]

    # First, parse just to get the config section and check for --version
    temp_args, _ = parser.parse_known_args(cmd_line_args)

    if temp_args.version:
        version_message = f"{PROGRAM_NAME} version {VERSION}"
        if temp_args.in_abc_bash_function:
            print(f'echo "{version_message}"')
        else:
            print(version_message)
        sys.exit(0)

    config_file_path = os.environ.get(f'{PROGRAM_NAME.upper()}_CONFIG', os.path.expanduser(DEFAULT_CONFIG_FILE))
    config = read_config_file(config_file_path)
    config_section = get_config_section(config, temp_args.config_section, config_file_path)

    # Now apply default options from the specified section and parse all arguments
    args = apply_default_options(parser, config_section, cmd_line_args)

    setup_logging(args.log_level)

    if args.in_abc_bash_function:
        if args.mode is not None:
            logging.error(f"Error: --mode option is not available when running {PROGRAM_NAME} as a bash function")
            sys.exit(1)
        args.mode = 'norun'

    if args.mode is None:
        args.mode = 'prompt'

    return args, config_section

def main() -> int:
    try:
        args, config_section = initialize()

        validate_description(args.description)
        bash_command = process_command(args.description, config_section)

        prompt_and_run(bash_command, args.mode)

        return 0

    except (ValueError, configparser.Error) as e:
        logging.error(f"{e}")
        return 1
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())