#!/usr/bin/env python3
"""

abc_generate - AI Bash Command Generator

Source and documentation:

  https://github.com/alestic/abc

Credits:

  Written by Claude 3.5 Sonnet
  Prompt crafting by Eric Hammond

"""

import argparse
import configparser
import logging
import os
import sys
from typing import List, Dict, Tuple

import anthropic
import distro

VERSION: str = "# 2024-07-15"
PROGRAM_NAME: str = "abc"

# Config file
DEFAULT_CONFIG_FILE: str = '~/.abc.conf'
DEFAULT_CONFIG_SECTION: str = 'default'

# Log format
LOG_FORMAT: str = f'%(asctime)s [{PROGRAM_NAME}] [%(levelname)s] %(message)s'
LOG_FORMAT_DATE: str = '%Y-%m-%d %H:%M:%S'

# LLM Constants
LLM_MODEL: str = "claude-3-5-sonnet-20240620"
LLM_TEMPERATURE: float = 0.0
LLM_MAX_TOKENS: int = 1000

def get_os_info():
    system = distro.name(pretty=True)
    version = distro.version(pretty=True)
    return f"{system} {version}".strip() or "POSIX"

SYSTEM_PROMPT: str = f"""You are an expert in bash commands for {get_os_info()}.
Given a description, generate the appropriate bash command(s) to accomplish the task.
Provide only the command(s) without any explanation.
Ensure the output can be directly copied and pasted into a terminal.
Use {get_os_info()}-specific commands when appropriate."""

def setup_logging(log_level: int) -> None:
    """Set up logging configuration."""
    logging.basicConfig(level=log_level, format=LOG_FORMAT, datefmt=LOG_FORMAT_DATE)

def create_argument_parser() -> argparse.ArgumentParser:
    """Create an argument parser for command-line arguments."""
    parser = argparse.ArgumentParser(description="abc_generate - AI Bash Command Generator")
    parser.add_argument('-c', '--config', type=argparse.FileType('r'),
                        default=os.environ.get('ABC_CONFIG', os.path.expanduser(DEFAULT_CONFIG_FILE)),
                        help='Path to configuration file')
    parser.add_argument('--version', action='version', version=VERSION,
                        help='Display the program version and exit')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--verbose', action='store_const',
                       const=logging.INFO, dest='log_level',
                       help='Provide detailed information about the program execution')
    group.add_argument('--debug', action='store_const',
                       const=logging.DEBUG, dest='log_level',
                       help='Provide debug information, use this only when troubleshooting')
    parser.set_defaults(log_level=logging.WARNING)

    parser.add_argument('description', nargs=argparse.REMAINDER,
                        help='English description of the desired bash command')
    return parser

def read_config_file(config_file_path: str) -> dict:
    """Read and parse the configuration file, using only the first section."""
    config = configparser.ConfigParser()
    with open(config_file_path, 'r') as config_file:
        config.read_file(config_file)
    if len(config.sections()) == 0:
        raise configparser.Error(f"Error: No sections found in config file '{config_file_path}'")
    first_section = config.sections()[0]
    return dict(config[first_section])

def get_args_and_config() -> Tuple[argparse.Namespace, Dict[str, str]]:
    """Create argument parser, read config, and parse command-line arguments."""
    parser = create_argument_parser()
    config_file_path = os.environ.get(f'{PROGRAM_NAME.upper()}_CONFIG', os.path.expanduser(DEFAULT_CONFIG_FILE))
    config = read_config_file(config_file_path)

    args = parser.parse_args()

    return args, config

def generate_bash_command(description: str, api_key: str) -> str:
    """Generate a bash command using the LLM based on the given description."""
    client = anthropic.Anthropic(api_key=api_key)

    message = client.messages.create(
        model=LLM_MODEL,
        max_tokens=LLM_MAX_TOKENS,
        temperature=LLM_TEMPERATURE,
        system=SYSTEM_PROMPT,
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": f"Description: {description}\n\nBash command(s):"
                    }
                ]
            }
        ]
    )

    return message.content[0].text.strip()

def process_command(description: List[str], config: Dict[str, str]) -> str:
    """Process the command description and generate bash command."""
    if not description:
        raise ValueError("No description provided")
    description_text = " ".join(description)
    logging.info(f"Generating bash command for: {description_text}")

    if 'api_key' not in config:
        raise ValueError("API key not found in configuration")

    return generate_bash_command(description_text, config['api_key'])

def main() -> int:
    try:
        args, config = get_args_and_config()
        setup_logging(args.log_level)

        bash_command = process_command(args.description, config)
        print(bash_command)

        return 0

    except (ValueError, configparser.Error) as e:
        logging.error(f"{e}")
        return 1
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())